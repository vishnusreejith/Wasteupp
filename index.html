<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BioBot AI - Biodiversity Index Calculator</title>
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. SheetJS (for reading Excel files) -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <!-- 3. Inter Font -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        /* Custom styles for dropzone */
        .dropzone {
            border: 2px dashed #cbd5e1;
            transition: all 0.3s ease;
        }
        .dropzone.drag-over {
            border-color: #2563eb;
            background-color: #eff6ff;
        }
        
        /* Custom styles for chatbot */
        #chat-messages {
            scroll-behavior: smooth;
        }
        .user-message {
            background-color: #e0f2fe; /* light blue */
            align-self: flex-end;
        }
        .bot-message {
            background-color: #f3f4f6; /* light gray */
            align-self: flex-start;
    <!-- Chatbot UI -->
    <button id="chat-open-btn" class="fixed bottom-6 right-6 bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 z-50">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    </button>

    <div id="chat-modal" class="fixed bottom-20 right-6 w-full max-w-md bg-white rounded-lg shadow-xl border border-gray-200 z-50 hidden flex flex-col" style="height: 60vh;">
        <!-- Chat Header -->
        <div class="flex items-center justify-between p-4 border-b border-gray-200 bg-gray-50 rounded-t-lg">
            <h3 class="text-lg font-semibold text-gray-900">Chat with BioBot</h3>
            <div class="flex items-center space-x-2">
                <button id="chat-mute-btn" class="text-gray-500 hover:text-gray-800">
                    <!-- Unmuted Icon -->
                    <svg id="icon-unmuted" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    <!-- Muted Icon (hidden by default) -->
                    <svg id="icon-muted" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="1" x2="1" y2="23"></line></svg>
                </button>
                <button id="chat-close-btn" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>
        
        <!-- Chat Messages -->
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto space-y-3">
            <!-- Initial bot message -->
            <div class="flex">
                <div class="bot-message rounded-lg p-3 max-w-xs text-sm">
                    Hello! I'm BioBot. Ask me anything about biodiversity, ecology, or this app.
                </div>
            </div>
        </div>
        
        <!-- "Bot is typing" indicator -->
        <div id="typing-indicator" class="p-4 pt-0 text-sm text-gray-500 hidden">
            <span class="animate-pulse">BioBot is typing...</span>
        </div>

        <!-- Chat Input -->
        <div class="p-4 border-t border-gray-200 bg-gray-50 rounded-b-lg">
            <div class="flex items-center space-x-2">
                <input type="text" id="chat-input" class="flex-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" placeholder="Type your message...">
                <button id="chat-send-btn" class="inline-flex items-center justify-center rounded-lg border border-transparent bg-blue-600 p-2 text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- STATE ---
            let activeTab = 'csv';
            let imageBase64Data = null;
            let isLoading = false;
            let chatHistory = [];
            let isChatMuted = false;
            
            // --- CONSTANTS ---
            const GEMINI_API_KEY = ""; // Leave blank, will be provided by environment
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
            const GEMINI_TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${GEMINI_API_KEY}`;
            const JSON_SCHEMA = {
                "type": "OBJECT",
                "properties": {
                    "species": {
                        "type": "ARRAY",
                        "items": {
                            "type": "OBJECT",
                            "properties": {
                                "name": { "type": "STRING", "description": "The common or scientific name of the species." },
                                "count": { "type": "NUMBER", "description": "The number of individuals of this species counted." }
                            },
                            "required": ["name", "count"]
                        }
                    }
                },
                "required": ["species"]
            };
            const CHAT_SYSTEM_PROMPT = "You are BioBot, a friendly and helpful AI assistant for the Biodiversity Index Calculator app. Your role is to answer questions about biodiversity (like 'What is the Shannon Index?'), ecology, and how to use the app. Keep your answers concise, informative, and easy to understand.";
            // Chatbot DOM Elements
            const chatOpenBtn = document.getElementById('chat-open-btn');
            const chatModal = document.getElementById('chat-modal');
            const chatCloseBtn = document.getElementById('chat-close-btn');
            const chatMuteBtn = document.getElementById('chat-mute-btn');
            const iconUnmuted = document.getElementById('icon-unmuted');
            const iconMuted = document.getElementById('icon-muted');
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-btn');
            const typingIndicator = document.getElementById('typing-indicator');

            // --- CORE APP FUNCTIONS ---
                            const counts = parseSpeciesList(lines);
                            calculateAndDisplayIndices(counts);
                        } catch (err) {
                            setErrorMessage(`Error parsing CSV: ${err.message}`);
                        }
                    };
                    reader.onerror = () => {
                        setErrorMessage('Error reading file.');
                    };
                    reader.readAsText(file);
                } else {
                    setErrorMessage("Please upload a CSV file or paste data first.");
                }
            }
            
            // --- Excel Handlers ---
            function handleExcelFile(file) {
                if (!file) {
                    setErrorMessage("No Excel file selected.");
                    return;
                }
                setLoading(true, 'Reading Excel file...');
                excelFilename.textContent = file.name;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        const json = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                        const speciesList = json.map(row => (row[0] || '').toString().trim()).filter(Boolean);
                        
                        if (speciesList.length === 0) {
                            setErrorMessage("No data found in the first column of the Excel file.");
                            return;
                        }
             * @param {string} apiUrl - The API endpoint to call.
             * @param {Object} payload - The payload to send to the API.
             * @param {number} [maxRetries=5] - Maximum number of retries.
             * @returns {Promise<Object>} - The JSON response from the API.
             */
            async function fetchWithRetry(apiUrl, payload, maxRetries = 5) {
                let attempt = 0;
                let delay = 1000;
                while (attempt < maxRetries) {
                    try {
                        const response = await fetch(apiUrl, {
                    const result = await fetchWithRetry(GEMINI_API_URL, payload);
                    
                    if (!result.candidates || !result.candidates[0].content.parts[0].text) {
                        throw new Error("Invalid response structure from AI.");
                    }
                    
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedData = JSON.parse(jsonText);
                    
                    if (!parsedData.species || parsedData.species.length === 0) {
                        setErrorMessage("AI analysis complete, but no species were identified.");
                        return;
                    }

            // --- CHATBOT FUNCTIONS ---

            /**
             * Toggles the chat modal visibility.
             */
            function toggleChat() {
                chatModal.classList.toggle('hidden');
                if (!chatModal.classList.contains('hidden')) {
                    chatInput.focus();
                }
            }

            /**
             * Adds a message to the chat UI.
             * @param {string} sender - 'user' or 'bot'.
             * @param {string} message - The text of the message.
             */
            function addChatMessage(sender, message) {
                const messageType = sender === 'user' ? 'user-message' : 'bot-message';
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : ''}`;
                messageDiv.innerHTML = `
                    <div class="${messageType} rounded-lg p-3 max-w-xs text-sm">
                        ${message}
                    </div>
                `;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            /**
             * Handles sending a chat message.
             */
            async function handleChatSend() {
                const userMessage = chatInput.value.trim();
                if (userMessage === '') return;

                addChatMessage('user', userMessage);
                chatInput.value = '';
                typingIndicator.classList.remove('hidden');

                // Add to history for context
                chatHistory.push({ role: "user", parts: [{ text: userMessage }] });

                try {
                    const botResponseText = await getBotResponse(userMessage);
                    addChatMessage('bot', botResponseText);
                    
                    // Add bot response to history
                    chatHistory.push({ role: "model", parts: [{ text: botResponseText }] });

                    if (!isChatMuted) {
                        playAudio(botResponseText);
                    }
                } catch (err) {
                    console.error("Chatbot error:", err);
                    addChatMessage('bot', "Sorry, I ran into an error. Please try again.");
                } finally {
                    typingIndicator.classList.add('hidden');
                }
            }

            /**
             * Gets a text response from the LLM.
             * @param {string} userMessage - The user's message (used for history, but payload uses full history).
             * @returns {Promise<string>} - The bot's text response.
             */
            async function getBotResponse(userMessage) {
                const payload = {
                    contents: chatHistory,
                    systemInstruction: {
                        parts: [{ text: CHAT_SYSTEM_PROMPT }]
                    },
                };

                const result = await fetchWithRetry(GEMINI_API_URL, payload);
                
                if (!result.candidates || !result.candidates[0].content.parts[0].text) {
                    throw new Error("Invalid response structure from AI.");
                }
                
                return result.candidates[0].content.parts[0].text;
            }
            
            /**
             * Toggles the chat audio mute state.
             */
            function toggleMute() {
                isChatMuted = !isChatMuted;
                iconUnmuted.classList.toggle('hidden', isChatMuted);
                iconMuted.classList.toggle('hidden', !isChatMuted);
            }

            // --- AUDIO (TTS) FUNCTIONS ---

            /**
             * Fetches audio from the TTS API and plays it.
             * @param {string} text - The text to synthesize.
             */
            async function playAudio(text) {
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Say with a friendly, upbeat tone: ${text}` }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Puck" } // A friendly, upbeat voice
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const result = await fetchWithRetry(GEMINI_TTS_API_URL, payload);
                    
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        playWavBlob(wavBlob);
                    } else {
                        throw new Error("Invalid audio data received.");
                    }
                } catch (err) {
                    console.error("TTS failed:", err);
                    // Don't show an error in the chat, just fail silently.
                }
            }
            
            /**
             * Decodes base64 string to ArrayBuffer.
             */
            function base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            /**
             * Plays a WAV audio blob.
             */
            function playWavBlob(wavBlob) {
                const audioUrl = URL.createObjectURL(wavBlob);
                const audio = new Audio(audioUrl);
                audio.play();
                audio.onended = () => URL.revokeObjectURL(audioUrl);
            }

            /**
             * Converts raw PCM16 data to a WAV blob.
             * @param {Int16Array} pcm16 - The raw audio data.
             * @param {number} sampleRate - The sample rate (e.g., 24000).
             * @param {number} [numChannels=1] - Number of audio channels.
             * @returns {Blob} - A WAV file as a Blob.
             */
            function pcmToWav(pcm16, sampleRate, numChannels = 1) {
                const numSamples = pcm16.length;
                const dataSize = numSamples * 2; // 16 bits = 2 bytes per sample
                const buffer = new ArrayBuffer(44); // 44 bytes for WAV header
                const view = new DataView(buffer);

                // Helper to write strings
                function writeString(view, offset, string) {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                }

                // RIFF chunk descriptor
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + dataSize, true); // chunk size
                writeString(view, 8, 'WAVE');
                
                // 'fmt ' sub-chunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // subchunk 1 size (16 for PCM)
                view.setUint16(20, 1, true);  // audio format (1 for PCM)
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * 2, true); // byte rate
                view.setUint16(32, numChannels * 2, true); // block align
                view.setUint16(34, 16, true); // bits per sample
                
                // 'data' sub-chunk
                writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true); // subchunk 2 size

                // Concatenate header and data
                return new Blob([view, pcm16], { type: 'audio/wav' });
            }

            // --- EVENT LISTENERS ---
            tabButtons.csv.addEventListener('click', () => switchTab('csv'));
            tabButtons.excel.addEventListener('click', () => switchTab('excel'));
            tabButtons.image.addEventListener('click', () => switchTab('image'));
            
            csvCalcButton.addEventListener('click', handleCsvCalculation);

            setupDropzone(excelDropzone, excelFileInput, handleExcelFile);
            setupDropzone(imageDropzone, imageFileInput, handleImageFile);

            imageCalcButton.addEventListener('click', handleImageCalculation);
            
            // Chatbot event listeners
            chatOpenBtn.addEventListener('click', toggleChat);
            chatCloseBtn.addEventListener('click', toggleChat);
            chatMuteBtn.addEventListener('click', toggleMute);
            chatSendBtn.addEventListener('click', handleChatSend);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleChatSend();
                }
            });

        });
    </script>
</body>
</html>