<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wasteupp</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for canvas interaction and overall look */
        body { font-family: 'Inter', sans-serif; background-color: #f7f7f7; }
        .container-wrapper {
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
        }
        #imageCanvas {
            border: 2px solid #3b82f6;
            cursor: crosshair;
            margin-top: 1rem;
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto;
            background-color: #e5e7eb;
        }
        .message-box {
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
        }
        .error {
            background-color: #fef2f2;
            color: #ef4444;
            border: 1px solid #fca5a5;
        }
        .info {
            background-color: #eff6ff;
            color: #3b82f6;
            border: 1px solid #93c5fd;
        }
    </style>
</head>
<body>

<div id="app" class="container-wrapper min-h-screen">
    <header class="text-center py-6">
        <h1 class="text-3xl font-extrabold text-gray-800"> Waste Density Analyzer</h1>
        <p class="text-gray-500 mt-1 font-semibold">Focuses only on Plastic, Paper, Glass, and Clothes.</p>
    </header>

    <div class="space-y-6 p-4 bg-white shadow-2xl rounded-xl">
        
        <!-- Step 1: Upload and Analyze -->
        <h2 class="text-xl font-semibold text-gray-800">1. Upload and Analyze Image</h2>
        <p class="text-sm text-red-600 font-bold">Image MUST contain a reference object (like a ruler) for scale.</p>
        <div>
            <label for="imageUpload" class="block text-sm font-medium text-gray-700">Upload Waste Image</label>
            <input type="file" id="imageUpload" accept="image/*" class="mt-1 block w-full p-2 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none">
        </div>

        <button id="analyzeButton" class="w-full px-4 py-2 text-white bg-green-600 rounded-lg hover:bg-green-700 focus:ring-4 focus:ring-green-500 transition duration-150 shadow-md disabled:bg-gray-400" disabled>
            Analyze Image (Filter Natural Debris)
        </button>

        <!-- Loading/Message Box -->
        <div id="messageContainer"></div>

        <!-- ANALYSIS SECTION (Now visible right after image load) -->
        <div id="analysisSection" class="hidden space-y-6">
            
            <!-- Step 2: Scale Input and Drawing -->
            <h2 class="text-xl font-semibold text-gray-800 pt-4">2. Set Real-World Scale</h2>
            <p class="text-sm text-gray-500 mb-2 font-bold text-red-700">Action: Click and drag a line on the canvas to match the length of your reference object.</p>
            
            <div id="scaleSetup" class="p-3 bg-yellow-50 rounded-lg border border-yellow-200 space-y-2">
                <div>
                    <label for="realLengthCm" class="block text-sm font-medium text-gray-700">Known Length of Reference Object (cm)</label>
                    <input type="number" id="realLengthCm" class="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 10" min="1">
                </div>
                <div id="scaleStatus" class="text-sm text-yellow-800 font-semibold">Scale not set. Draw the reference length first.</div>
            </div>

            <!-- Canvas for Drawing -->
            <canvas id="imageCanvas" class="w-full rounded-lg"></canvas>

            <!-- Step 3: Sampling -->
            <h2 id="samplingTitle" class="text-xl font-semibold text-gray-800 pt-4 hidden">3. Sample Area Selection</h2>
            <p id="samplingInstructions" class="text-sm text-gray-500 mb-2 hidden">Click and drag a rectangle to select a sampling area. (Requires Step 1 analysis results.)</p>


            <!-- Results Section -->
            <div id="resultsContainer" class="space-y-4">
                
                <div id="aiResults" class="mt-4 p-4 bg-blue-50 rounded-lg shadow-inner">
                    <h3 class="text-lg font-bold text-blue-800">AI Baseline Analysis (Count of Items)</h3>
                    <div id="aiCounts" class="text-sm mt-1 text-blue-700">Waiting for analysis results...</div>
                </div>

                <div id="finalResults" class="p-4 bg-purple-50 rounded-lg shadow-inner border-l-4 border-purple-500">
                    <h3 class="text-lg font-bold text-purple-800">Final Waste Concentration</h3>
                    <p id="sampleAreaDisplay" class="text-sm mt-1 text-purple-700">Scale not set.</p>
                    <p id="totalExtrapolation" class="text-base font-extrabold text-purple-900 mt-2">Estimated TOTAL Items: N/A</p>
                    <p id="realWorldDensity" class="text-xl font-extrabold text-red-600 mt-3">Real-World Density: N/A items/cm²</p>
                </div>
            </div>
        </div>

    </div>
</div>

<script>
    // --- Configuration and Global Variables ---
    const API_MODEL = "gemini-2.5-flash-preview-09-2025";
    const apiKey = "AIzaSyC1VvKz8rrFWYx0AIm8UrAFnf7jCYvV8DA"; 

    const uploadInput = document.getElementById('imageUpload');
    const analyzeButton = document.getElementById('analyzeButton');
    const messageContainer = document.getElementById('messageContainer');
    const analysisSection = document.getElementById('analysisSection');
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const realLengthCmInput = document.getElementById('realLengthCm');
    const scaleStatus = document.getElementById('scaleStatus');
    const samplingTitle = document.getElementById('samplingTitle');
    const samplingInstructions = document.getElementById('samplingInstructions');
    const aiCountsDiv = document.getElementById('aiCounts');

    const image = new Image();
    let originalImageWidth = 0;
    let originalImageHeight = 0;
    let analysisData = null; 
    let totalExtrapolatedCount = 0; 
    let realWorldScaleFactor = 0; // cm per pixel

    // Drawing State
    let isDrawing = false;
    let startX, startY;
    let currentMode = 'scale'; // 'scale' or 'sample'
    let scaleLine = null; // { x1, y1, x2, y2 } in canvas coordinates
    let sampleArea = { x: 0, y: 0, w: 0, h: 0 }; // rectangle for sampling

    // --- Utility Functions ---

    function fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file);
        });
    }

    async function exponentialBackoffFetch(url, options, retries = 5, delay = 1000) {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(url, options);
                if (response.ok) return response;
                if (response.status === 429 && i < retries - 1) { 
                    console.log(`Rate limit hit, retrying in ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; 
                    continue;
                }
                throw new Error(`API request failed with status: ${response.status}`);
            } catch (error) {
                if (i === retries - 1) throw error;
                console.error(`Fetch attempt ${i + 1} failed:`, error);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2; 
            }
        }
    }

    function showMessage(message, type) {
        messageContainer.innerHTML = `<div class="message-box ${type}">${message}</div>`;
    }

    function clearMessage() {
        messageContainer.innerHTML = '';
    }

    // --- Core AI Logic ---

    async function analyzeImage(base64Image) {
        showMessage('Analyzing image... This may take a moment.', 'info');
        analyzeButton.disabled = true;

        const totalPixelArea = originalImageWidth * originalImageHeight;
        
        // **UPDATED SYSTEM PROMPT** to strictly enforce man-made waste only
        const systemPrompt = `You are an expert waste analysis system focused ONLY on anthropogenic debris. Your task is to accurately estimate the count of man-made waste items: plastic, paper, wrappers, glass, and clothes/textiles.

        CRITICAL INSTRUCTION: You MUST ignore and exclude all natural objects such as stones, rocks, twigs, leaves, dirt, and biological debris from your count.

        Aggregate the count into three categories: 'plastic_count' (for plastic items and wrappers), 'paper_count' (for paper and cardboard), and 'other_man_made_count' (for glass and clothes/textiles).

        The image has a width of ${originalImageWidth} and height of ${originalImageHeight} pixels. Total area is ${totalPixelArea} pixels.
        
        Provide the output ONLY as a JSON object following this strict schema:
        {
          "plastic_count": <estimated_number_of_plastic_and_wrapper_items_integer>,
          "paper_count": <estimated_number_of_paper_and_cardboard_items_integer>,
          "other_man_made_count": <estimated_number_of_glass_and_textile_items_integer>,
          "density_factor_per_pixel": <total_estimated_man_made_items_divided_by_total_pixel_area_float>
        }`;

        const userQuery = "Estimate the counts for plastic/wrappers, paper/cardboard, and glass/clothes. Only count man-made waste.";

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: uploadInput.files[0].type,
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "plastic_count": { "type": "INTEGER", "description": "The estimated number of plastic and wrapper items." },
                        "paper_count": { "type": "INTEGER", "description": "The estimated number of paper and cardboard items." },
                        "other_man_made_count": { "type": "INTEGER", "description": "The estimated number of glass and textile/clothes items." },
                        "density_factor_per_pixel": { "type": "NUMBER", "description": "The total estimated man-made count divided by the total pixel area (float)." }
                    },
                    required: ["plastic_count", "paper_count", "other_man_made_count", "density_factor_per_pixel"]
                }
            }
        };

        const apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${apiKey}`;

        try {
            const response = await exponentialBackoffFetch(apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (!jsonText) {
                throw new Error("AI returned no content. Check API logs for block reasons.");
            }

            const data = JSON.parse(jsonText);
            
            analysisData = data;
            
            totalExtrapolatedCount = analysisData.density_factor_per_pixel * totalPixelArea;

            displayAIResults(data);
            
            // Allow sampling (Step 3) only after successful analysis
            if (currentMode === 'scale') {
                 showMessage('Analysis complete! Please complete the scale line drawing and input its length (Step 2).', 'info');
            } else {
                 currentMode = 'sample';
                 samplingTitle.classList.remove('hidden');
                 samplingInstructions.classList.remove('hidden');
                 showMessage('Analysis complete and scale is set. Now click and drag to define your sampling area (Step 3).', 'info');
            }


        } catch (error) {
            console.error('Gemini API Error:', error);
            showMessage(`Analysis failed: ${error.message}. Please check console for details.`, 'error');
            analysisData = null;
            // Reset results display if analysis fails
            aiCountsDiv.innerHTML = 'Analysis failed.';
        } finally {
            analyzeButton.disabled = false;
        }
    }
    
    // --- Display and Calculation Logic ---

    function displayAIResults(data) {
        const totalItemsBaseline = data.plastic_count + data.paper_count + data.other_man_made_count;
        
        aiCountsDiv.innerHTML = `
            <p class="text-sm mt-1 text-blue-700">Estimated Plastic/Wrappers: ${data.plastic_count}</p>
            <p class="text-sm text-blue-700">Estimated Paper/Cardboard: ${data.paper_count}</p>
            <p class="text-sm text-blue-700">Estimated Glass/Clothes: ${data.other_man_made_count}</p>
            <p class="text-sm font-semibold text-blue-800 mt-2">TOTAL Man-Made Items: ${totalItemsBaseline.toFixed(0)} items</p>
            <p class="text-sm text-blue-700">Pixel Density Factor: ${data.density_factor_per_pixel.toExponential(4)} items/pixel²</p>
        `;
        
        updateFinalResults();
    }

    /**
     * Calculates the real-world scale factor (cm/pixel) based on the drawn line.
     */
    function calculateScaleFactor() {
        if (!scaleLine) return 0;
        const realLengthCm = parseFloat(realLengthCmInput.value);

        if (isNaN(realLengthCm) || realLengthCm <= 0) {
            scaleStatus.textContent = 'ERROR: Please enter a valid known length in centimeters.';
            realWorldScaleFactor = 0;
            updateFinalResults();
            return 0;
        }

        const pixelLength = Math.sqrt(
            Math.pow(scaleLine.x2 - scaleLine.x1, 2) + 
            Math.pow(scaleLine.y2 - scaleLine.y1, 2)
        );

        if (pixelLength < 10) { 
            scaleStatus.textContent = 'ERROR: Drawn line is too short. Please draw a longer line segment.';
            realWorldScaleFactor = 0;
            updateFinalResults();
            return 0;
        }

        const canvasScaleFactor = canvas.width / originalImageWidth;
        const originalPixelLength = pixelLength / canvasScaleFactor;
        
        realWorldScaleFactor = realLengthCm / originalPixelLength;
        
        scaleStatus.innerHTML = `
            <span class="text-green-700">Scale Set!</span> Pixel Length: ${originalPixelLength.toFixed(1)} pixels. 
            Scale Factor: ${realWorldScaleFactor.toFixed(6)} cm/pixel.
        `;
        
        // If analysis is done, switch to sampling mode
        if (analysisData) {
            currentMode = 'sample';
            samplingTitle.classList.remove('hidden');
            samplingInstructions.classList.remove('hidden');
            showMessage('Scale is set and analysis is ready. Click and drag to define your sampling area (Step 3).', 'info');
        } else {
             showMessage('Scale set! Now click "Analyze Image" (Step 1) to get the density factor.', 'info');
        }

        redrawCanvas();
        updateFinalResults();
        return realWorldScaleFactor;
    }

    /**
     * Calculates and displays the final results in real-world units.
     */
    function updateFinalResults() {
        // Default text for final results
        let sampleAreaDisplayHtml = 'Scale not set.';
        let totalExtrapolationText = 'Estimated TOTAL Man-Made Items: N/A';
        let realWorldDensityHtml = 'Real-World Density: N/A items/cm²';

        if (analysisData) {
            totalExtrapolationText = `Estimated TOTAL Man-Made Items: ${totalExtrapolatedCount.toFixed(0)} items`;
        }

        
        if (realWorldScaleFactor > 0) {
            // Calculate the total area in cm^2 using the scale factor
            const totalRealAreaCm2 = originalImageWidth * originalImageHeight * Math.pow(realWorldScaleFactor, 2);
            
            if (analysisData) {
                const realWorldDensity = totalExtrapolatedCount / totalRealAreaCm2;
                
                realWorldDensityHtml = `
                    <span class="text-xl font-extrabold text-red-600 mt-3 block">
                        Real-World Density: ${realWorldDensity.toFixed(4)} items/cm²
                    </span>
                    <span class="text-sm text-red-600/80 block">
                        (Total Area: ${totalRealAreaCm2.toFixed(1)} cm²)
                    </span>
                `;

                // --- Sample Area Calculation (Only if analysis is done and scale is set) ---
                if (sampleArea.w > 0 && sampleArea.h > 0) {
                    
                    const sampleAreaPixels = sampleArea.w * sampleArea.h;
                    const canvasScaleFactor = canvas.width / originalImageWidth;
                    const originalSampleAreaPixels = sampleAreaPixels / Math.pow(canvasScaleFactor, 2);
                    
                    const sampleAreaCm2 = originalSampleAreaPixels * Math.pow(realWorldScaleFactor, 2);
                    const sampleTotalCount = sampleAreaCm2 * realWorldDensity;
                    
                    // Break down sample count by type using AI's initial ratio
                    const totalBaselineCount = analysisData.plastic_count + analysisData.paper_count + analysisData.other_man_made_count;
                    
                    const plasticRatio = analysisData.plastic_count / totalBaselineCount;
                    const paperRatio = analysisData.paper_count / totalBaselineCount;
                    const otherRatio = analysisData.other_man_made_count / totalBaselineCount;

                    const samplePlasticCount = sampleTotalCount * plasticRatio;
                    const samplePaperCount = sampleTotalCount * paperRatio;
                    const sampleOtherCount = sampleTotalCount * otherRatio;

                    sampleAreaDisplayHtml = `
                        <p class="text-sm mt-1 text-purple-700 font-bold">Sample Area: ${sampleAreaCm2.toFixed(2)} cm²</p>
                        <p class="text-base font-semibold text-purple-700">Est. Plastic/Wrappers in Sample: ${samplePlasticCount.toFixed(2)} items</p>
                        <p class="text-base font-semibold text-purple-700">Est. Paper/Cardboard in Sample: ${samplePaperCount.toFixed(2)} items</p>
                        <p class="text-base font-semibold text-purple-700">Est. Glass/Clothes in Sample: ${sampleOtherCount.toFixed(2)} items</p>
                    `;
                } else {
                    sampleAreaDisplayHtml = 'Draw a sample rectangle above to see the count in a specific area (Step 3).';
                }

            } else {
                 // Scale is set, but analysis is pending
                realWorldDensityHtml = 'Real-World Density: Awaiting AI Analysis.';
                sampleAreaDisplayHtml = 'Awaiting AI Analysis.';
            }

        }

        // Update UI elements
        document.getElementById('sampleAreaDisplay').innerHTML = sampleAreaDisplayHtml;
        document.getElementById('totalExtrapolation').textContent = totalExtrapolationText;
        document.getElementById('realWorldDensity').innerHTML = realWorldDensityHtml;
    }


    // --- Canvas Drawing Handlers ---

    function redrawCanvas() {
        if (!image.complete) return;
        
        const containerWidth = canvas.parentElement.clientWidth;
        const canvasWidth = containerWidth;
        const canvasHeight = (containerWidth / originalImageWidth) * originalImageHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        // Draw the Scale Line (if set)
        if (scaleLine) {
            ctx.strokeStyle = '#059669'; // Green for scale
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(scaleLine.x1, scaleLine.y1);
            ctx.lineTo(scaleLine.x2, scaleLine.y2);
            ctx.stroke();
        }

        // Draw the Sample Area (if set and mode is sample)
        if (currentMode === 'sample' && sampleArea.w > 0 && sampleArea.h > 0) {
            ctx.strokeStyle = '#ef4444'; // Red for sample
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]); 
            ctx.strokeRect(sampleArea.x, sampleArea.y, sampleArea.w, sampleArea.h);
            ctx.setLineDash([]); 
        }
    }

    function getCanvasCoords(event) {
        const rect = canvas.getBoundingClientRect();
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function handleStart(e) {
        // FIX: Remove check for analysisData. Now only check if image is loaded.
        if (!image.complete) return; 
        
        e.preventDefault();
        isDrawing = true;
        const coords = getCanvasCoords(e);
        startX = coords.x;
        startY = coords.y;

        if (currentMode === 'scale') {
            scaleLine = { x1: startX, y1: startY, x2: startX, y2: startY };
            scaleStatus.textContent = 'Drawing scale line...';
        } else if (currentMode === 'sample') {
            // Only allow sampling if analysis is complete
            if (!analysisData) {
                 isDrawing = false;
                 showMessage('Please click "Analyze Image" (Step 1) before defining a sample area.', 'error');
                 return;
            }
            sampleArea = { x: 0, y: 0, w: 0, h: 0 };
        }
        redrawCanvas();
    }

    function handleMove(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const coords = getCanvasCoords(e);
        const currentX = coords.x;
        const currentY = coords.y;

        if (currentMode === 'scale') {
            scaleLine.x2 = currentX;
            scaleLine.y2 = currentY;
        } else if (currentMode === 'sample') {
            if (!analysisData) return; // double check if analysis is done
            
            const w = currentX - startX;
            const h = currentY - startY;

            sampleArea.x = Math.min(startX, currentX);
            sampleArea.y = Math.min(startY, currentY);
            sampleArea.w = Math.abs(w);
            sampleArea.h = Math.abs(h);
        }
        redrawCanvas();
    }

    function handleEnd(e) {
        if (!isDrawing) return;
        e.preventDefault();
        isDrawing = false;
        
        if (currentMode === 'scale') {
            calculateScaleFactor();
        } else if (currentMode === 'sample') {
            if (!analysisData) return; // double check if analysis is done
            
            if (sampleArea.w > 5 && sampleArea.h > 5) { 
                updateFinalResults();
            } else {
                sampleArea = { x: 0, y: 0, w: 0, h: 0 };
                redrawCanvas();
                updateFinalResults();
            }
        }
    }


    // --- Event Listeners ---

    uploadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                image.onload = () => {
                    originalImageWidth = image.naturalWidth;
                    originalImageHeight = image.naturalHeight;
                    
                    // FIX 1: Make analysis section visible immediately so user can see image
                    analysisSection.classList.remove('hidden'); 

                    redrawCanvas(); 
                    
                    analyzeButton.disabled = false;
                    analysisData = null; 
                    realWorldScaleFactor = 0;
                    scaleLine = null;
                    sampleArea = { x: 0, y: 0, w: 0, h: 0 };
                    currentMode = 'scale'; 
                    scaleStatus.textContent = 'Draw the reference length first.';
                    clearMessage();
                    showMessage('Image loaded. Now draw the reference line (Step 2) and click "Analyze" (Step 1).', 'info');
                };
                image.src = event.target.result;
            };
            reader.readAsDataURL(file);
        } else {
            analyzeButton.disabled = true;
            analysisSection.classList.add('hidden');
        }
    });

    analyzeButton.addEventListener('click', async () => {
        const file = uploadInput.files[0];
        if (!file) {
            showMessage('Please upload an image first.', 'error');
            return;
        }

        try {
            const base64Image = await fileToBase64(file);
            await analyzeImage(base64Image);
        } catch (error) {
            console.error('File processing error:', error);
            showMessage('Could not process the image file.', 'error');
        }
    });
    
    // Recalculate scale and results if the user changes the known length
    realLengthCmInput.addEventListener('input', () => {
        if (scaleLine) {
            calculateScaleFactor();
        }
    });

    // Canvas Events
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', handleEnd); 

    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('touchend', handleEnd);

    // Initial message
    window.onload = () => {
        showMessage('Upload an image to begin the waste analysis process. Ensure your image includes a physical reference object (like a ruler).', 'info');
    };
</script>

</body>
</html>

